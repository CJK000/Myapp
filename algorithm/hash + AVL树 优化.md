#### hash + AVL树 优化

​	用了字典树优化之后程序运行速度得到了质的飞跃，但是空间复杂度过高的缺点就暴露得很明显了，只能生成数量级是十万道题目，鉴于要满足队友贪婪的欲望，给我提出要能生成一千万道题目的合理要求，无法拒绝，决定采用字符串哈希 + 平衡树 来优化查重算法。

##### 字符串哈希

哈希公式：$hash[i] = (hash[i-1]*p+str[i]) \% mod $

​	str[i] 为第字符串第 i 个字符的 ASCII 码

​	p 为一个素数，这里取 127

​	mod 为一个素数，这里取 99999999999973

```c++
long long mod = 99999999999973;
long long Hash(string &s) {
	long long ret=0;
	int i;
	int len = s.length();
	for (i = 0; i < len; i++) {
		ret = (ret * 127 + s[i]) % mod;
	}
	return ret;
}
```



##### AVL树

本程序需要采用平衡树存储 hash 值，AVL树是所有平衡树中速度最快的，所以采用AVL树，

```c++
struct AVL {
	AVL *lchild, *rchild;	//左右儿子指针
	long long val;	//存储的哈希值
	int height;	//树高
	AVL() {};
	AVL(long long n) {
		val = n;
		lchild = NULL;
		rchild = NULL;
	}
};
```

##### 时间复杂度

单词插入操作的复杂度：O(L+logN)，L为字符串的长度，N为当前已生成题目的数量，字典树优化的时间复杂度是 O(L)，所以速度会较慢

##### 空间复杂度

O(N)，N为生成题目数量，每一个题目只需要消耗一个结构体的内存，即24字节，而字典树最坏情况的空间复杂度是指数级的。

##### 运行测试

经检验，生成一千万个不重复的题目时需要消耗 700MB 左右的内存，程序可以使用的内存时 2GB，运行测试可发现最多可以生成 3200万 道不重复得题目

![](https://img2020.cnblogs.com/blog/1814040/202004/1814040-20200414174508888-878006587.png)

![](https://img2020.cnblogs.com/blog/1814040/202004/1814040-20200414174516943-661276563.png) 

